import { NextResponse } from 'next/server';
import OpenAI from 'openai';

export async function POST(request) {
  try {
    // 1. Parse the JSON body
    const {
      examType = 'Practice Exam',
      difficulty = 'Basic',
      lawSubject = 'General Law',
      selectedQuestionTypes = [],
      questionLimit = 5,
      instantFeedback = false,
      includeCurveBalls = false,
      allowMultipleChoice = true,
      preferEssayStyle = false,
      // ... any other fields as needed
    } = await request.json();

    // 2. Build a difficulty description (example)
    const lawStudentDifficultyDetails = {
      Basic:
        'introductory-level complexity for a law student with basic familiarity of the subject',
      Intermediate:
        'moderate complexity requiring some knowledge of underlying legal doctrines',
      Advanced:
        'high complexity demanding deeper legal reasoning and nuanced analysis',
      Expert:
        'expert-level complexity reflecting mastery with highly sophisticated arguments',
    };
    const difficultyDescription = lawStudentDifficultyDetails[difficulty] || difficulty;

    // 3. Collect question type info
    let questionTypesBlock = '';
    if (Array.isArray(selectedQuestionTypes) && selectedQuestionTypes.length > 0) {
      questionTypesBlock = 'The question should incorporate the following style/elements:\n';
      selectedQuestionTypes.forEach((type) => {
        questionTypesBlock += `- ${type}\n`;
      });
    }

    // 4. Construct the prompt to GPT
    let prompt = `
You are an expert exam question writer focusing on law students' practice exams. 
Create a well-formatted question covering "${lawSubject}" at a "${difficultyDescription}" level. 
Exam Type/Purpose: ${examType}

Details:
- questionLimit: ${questionLimit}
- instantFeedback: ${instantFeedback ? 'enabled' : 'disabled'}
- includeCurveBalls: ${includeCurveBalls ? 'yes' : 'no'}
- allowMultipleChoice: ${allowMultipleChoice ? 'yes' : 'no'}
- preferEssayStyle: ${preferEssayStyle ? 'yes' : 'no'}

${questionTypesBlock || ''}

**Requirements**:
1. Provide a concise but sufficiently detailed Fact Pattern:
   - The scenario must be relevant to ${lawSubject}.
   - Should contain legal or factual nuances typical of a law school exam.

2. Provide separate question(s). 
   - If essay style, separate out the sub-questions with headings like "Question 1:", "Question 2:", etc.
   - If multiple-choice, label answers exactly as (A), (B), (C), (D), (E), each on a new line.

3. Use clear section headings, for example:
   "Fact Pattern:" 
    <some lines of text>
   
   "Question 1:" 
    <the question or sub-question>
   
   "Question 2:" 
    ... etc.

4. Do not provide solutions or commentary, only the final text of the question. 
5. Avoid disclaimers, apologies, or extraneous conversation. 
6. No markdown formatting, no asterisks, no code fences. 
7. Output must be easily readable: 
   - Insert blank lines where appropriate between the Fact Pattern and the questions. 
   - Avoid huge paragraphs without line breaks.

Return only this question text, nothing else.
`;

    // 5. Call GPT (here using GPT-4) 
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 1200,
      temperature: 0.7,
    });

    // 6. Validate
    if (
      !response ||
      !response.choices ||
      !Array.isArray(response.choices) ||
      response.choices.length === 0 ||
      !response.choices[0].message ||
      !response.choices[0].message.content
    ) {
      console.error('Unexpected response structure from OpenAI:', response);
      throw new Error('Unexpected response from OpenAI.');
    }

    let question = response.choices[0].message.content.trim();

    if (!question) {
      console.error('OpenAI returned no question text.');
      throw new Error('No question generated by AI.');
    }

    // 7. Optional Post-processing:
    // If GPT forgot to add some spacing or headings, let's do some
    // simple replacements or line breaks. For instance, if we detect
    // "Fact Pattern:", but there's no blank line after, we can add one:
    question = question.replace(/Fact Pattern:\s*/gi, 'Fact Pattern:\n\n');
    question = question.replace(/Question\s+(\d+):\s*/gi, 'Question $1:\n\n');

    // 8. Return
    return NextResponse.json({ question }, { status: 200 });
  } catch (error) {
    console.error('Error generating question:', error);
    return NextResponse.json(
      { error: 'An error occurred while generating the exam question.' },
      { status: 500 }
    );
  }
}
